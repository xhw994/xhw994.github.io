---
title: 不单纯程序员们的婚恋与语言困境以及博弈
date: 2019-04-13 19:54:29
categories:
- 随笔
tags:
- 算法
- 生活
---

# “单纯”的程序员

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据我在社交平台上的观察，国内的程序员们总是要和HR们怼着干的。这一方面来自于程序员们对HR这种“非实干”岗位的不屑，认为他们就是陪人聊天和发工资的；另一方面也来自于HR对于程序员所普遍具有的单纯、肯干、童贞的老实人刻板形象的不屑。他们认为程序员们是要被引导的一方，而自己就是他们的牧羊人。但俗话说的好：“亲不亲，阶级分”。如果说程序员和PM间的明争暗斗尚可理解，和HR这种没有明显的利益和阶级纠纷的部门杠架实属找错了对手。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;斗争的对错暂且按下不提，但促使我写这篇文章的理由的确来自几天前网络平台上程序员与某HR的又一次博弈。具体来说就是这张网上流传出来的“求偶”文。
<center>![](/images/201904/1.jpg)</center>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多么甜美的陷阱啊，资产过亿的清华高材竟然想找个靠谱IT男过日子，除了“不要特别矮或者胖”和“88年”两条信息外没有任何附加需求。看到这里我真觉得这是对广大程序员的智商和情商赤裸裸的侮辱。但哪怕程序员知道这是骗局又能怎么办呢？“高智商”这三个字比任何挑逗都要有效。明知山有HR，挑战者们也要向HR山行，这才是有实干精神、不畏挑战的标兵程序员。当然，出现接下来的情况便是意料之中了。
<center>![](/images/201904/2.jpg)</center>
<center>![](/images/201904/3.jpg)</center>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;翻看原微博的评论区，我发现这条羊头狗肉的招聘信息比我预想中的还有效。此HR的微信的好友位在当天晚上就已经被占据一空，并且她至少注册了另外两个微信号来处理大量的好友通知。我虽然觉得这种猎头方式很蠢，但也不得不说在中国这片辽阔的土地上存在着太多的冒险家和娱乐家。这场智斗表面上的赢家虽然是成功揭发伪装的程序员，但真正的赢家却是收到了大量简历的HR。不可谓道高一尺魔高一丈。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么本着程序员的实干精神，我也来试试这道题，全当娱乐了。

# 娱乐与被娱乐
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两道都是数学题。我心想既然电脑上没装Matlab，那就用Haskell写好了。正好我也有点怀念Haskell的语法了。

## 双因子问题
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先解决质数因子的问题。这里使用的是最直白最容易实现的[试除法](https://zh.wikipedia.org/wiki/试除法)：

{% codeblock lang:Haskell 试除法 %}
divisors:: Int -> [Int]
divisors n = [i | i <- [2..(n `div` 2)], n `mod` i == 0]

-- 并未用到的无限质数列表
primes :: [Int]
primes = [i | i <- [2..], divisors i == []]

primeFactors :: Int -> [Int]
primeFactors n = case divs of
    [] -> [n]
    _ -> reverse $ divs ++ primeFactors(n `div` (head divs))
    where divs = take 1 $ divisors n
{% endcodeblock %}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这里的返回结果必定是从小到大排列的，我需要用到`reverse`函数把它翻过来。得到的结果是86627和8171，用时小于1毫秒。因为我的目标（707829217）并不是一个很大的数字，这种算法比[埃拉托斯特尼筛法](https://zh.wikipedia.org/wiki/埃拉托斯特尼筛法)和[Wheel factorization](https://en.wikipedia.org/wiki/Wheel_factorization)（第三方库[Data.Numbers.Primes](https://hackage.haskell.org/package/primes-0.2.1.0/docs/Data-Numbers-Primes.html)的默认算法，第一步取n=6）要快一些。至于[更复杂的](http://www.csie.ntnu.edu.tw/~u91029/Prime.html)筛选法，那就是用大炮打蚊子了。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来我写了一个`join`函数将返回的两个值并成一个，方便我接下来的计算，免得重复进行复制粘贴。注意这里要用Integer来防止数值溢出：

{% codeblock lang:Haskell 合并数字 %}
join :: [Int] -> Integer
join = read . concatMap show
{% endcodeblock %}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一步的结果自然是866278171。这大概是那位HR的QQ号吧。如果是真的话我怀疑她的QQ号也被好友塞爆了。

## 数3的第一种方法

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后是第二个问题，计算从1到866278171为止的所有奇数总共有多少个3。比如3333这个数就含有4个3，1不包含3，这样。那么首先我要写一个函数计算单一整数有几个3：

{% codeblock lang:Haskell 计算整数中3的数量 %}
count :: Integer -> Integer
count 0 = 0
count n = (if n `mod` 10 == 3 then 1 else 0) + count (n `div` 10)
{% endcodeblock %}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用了模除法，从个位数向首位逐一判断当前数位是否为3。接下来我就可以计算从1到n的奇数中总共有多少个3了。因为除了2以外的质数都是奇数，而奇数相乘只能获得奇数，我只需要使用`n - 2`就能完成迭代的条件了。又因为比3小的数字不可能含有3，所以基准情况可以设为3：

{% codeblock lang:Haskell 计算从3到n的奇数中总共出现了多少个3 %}
countThree :: Integer -> Integer
countThree n
    | n == 3 = 1
    | otherwise = count n + countThree (n - 2)
{% endcodeblock %}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一步的结果是，喜出望外、意料之中的，堆栈溢出！

> Prelude Main> countThree $ join $ primeFactors o
> *** Exception: stack overflow

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;毕竟这是Haskell，只有递归嘛，4亿个函数堆叠在一起，溢出是可以理解的。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为逻辑非常简单，我可以确保这个函数是正确的。事实上，它的确可以计算到7位为止的整数：

> Prelude Main> countThree 8662781
> 3550568
> (2.06 secs, 1,150,702,176 bytes)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7位数就已经吞掉一个多GB，我的电脑只有8GB内存当然是不够它看的了。

## 数3的第二种方法：严格求值
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然结果是正确的，那我只需要尝试优化这个函数就可以了。首先我想到的是[惰性求值](https://zh.wikipedia.org/wiki/惰性求值)问题。Haskell是一个惰性语言，这在许多情况下都能优化运算效率。毕竟Spark和Linq都是惰性求值的，我没有道理怀疑它的优点。但Haskell是一个没有循环只有递归的语言，这就会造成许多问题了。我现在遇到的问题也许便是如此。如果展开`countThree`函数的话，它在堆栈上长这个样子：

> count n + countThree(n-2)
> count n + (count(n-2) + countThree(n-4))
> count n + (count(n-2) + (count(n-4) + countThree(n-6)))
> ...
> count n + (count(n-2) + ... + count(5) + count(3))

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意到Haskell的`+`运算符是严格求值的，它必须等待左右两边完全展开后才会进行运算，因此除非我优化递归函数本身，它必定会进行惰性运算——哪怕我用`seq`函数也不例外：

{% codeblock lang:Haskell 使用seq的严格求值 %}
countThreeSeq :: Integer -> Integer
countThreeSeq n
    | n == 3 = 1
    | otherwise = count n `seq` (count n + countThreeSeq (n - 2))
{% endcodeblock %}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了验证这一点，我启用了GHCI的最优化编译模式`ghci -fobject-code -O2`，编译后的结果仍然是堆栈溢出，只不过这次只用了不到5秒就报错了，比起之前的将近10秒还是有一定的进步。这里我想GHCI应该是是用了类似C++的Inline Function的方式来编译Count函数吧，待验证。

## 数3的第三种方法：尾调用

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尝试严格求值并没有取得任何成果，另一个方式便是优化递归函数了。经常写递归的人应该已经发现我第一个`countThree`函数的问题了：这不是一个[尾调用](https://zh.wikipedia.org/zh-cn/尾调用)函数。那么使用尾调用的结果如何呢？

{% codeblock lang:Haskell 使用尾调用 %}
countThree :: Integer -> Integer
countThree n = countThree' n 0 where
    countThree' n c
        | n == 3 = c
        | otherwise = countThree' (n - 2) (c + (count n))
{% endcodeblock %}

> Prelude Main> countThree $ join $ primeFactors o
> 441684626
> (250.44 secs, 136,963,604,072 bytes)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然用了4分多钟才运行完，但总算有结果了，它似乎又是一个QQ号。虽然应该没有这么巧的事情吧，但没准这个号的背后也是一个居心叵测的HR呢。我已经停用QQ很多年了就不去验证这么无聊的问题了，螃蟹留给其他人吃就好。

## 数3的第四种方法：fold

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;真正的鲁迅粉丝是要凑够4种写法的。这里我想试验的方式分为3个步骤：
1. 生成从3到866278171的奇数序列
2. 分别计算每个奇数中3的个数，生成一个新的序列
3. 求整个序列的和

{% codeblock lang:Haskell 使用fold遍历列表 %}
countThreeF :: Integer -> Integer
countThreeF n = foldl1 (+) $ map count [3,5..n]
{% endcodeblock %}

效率如下：

> Prelude Main> countThreeF $ join $ primeFactors o
> 441684627
> (254.24 secs, 171,614,745,432 bytes)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历了两遍并且使用了更多的内存，实在不能说是更优解。当然，因为866278171小于int32的最大值，我可以把Integer替换为Int来获取一定的空间效率。结果的确是快多了：

> Prelude Main> countThreeF' 866278171
> 441684627
> (85.30 secs, 41,581,489,720 bytes)

## 随想

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对这两道题的探究就到此为止。这次使用Haskell的体验真的很棒。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也许是小众文化的自我陶醉情绪使然吧，我从一开始接触Haskell就觉得它是一个相当有魅力的语言。虽然函数式会在未来的任意时间点都不会超越面向对象编程语言的热度，但我必须要赞美它对计算机语言发展的贡献。匿名函数、头等函数、惰性运算等特性都已经被植入到各大面向对象编程语言中了。JavaScript和C# 7.0甚至鼓励使用`=>`替代常规的声明方法。这足以证明函数式在某些方面的优越性。

# 非英语母语的困境

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说起HR就让我想起一个月前的面试经历了。我面的是某人力资源软件的.NET开发部门，在挺过HR的电话和第一轮Phone Screen后，HR发了一份网上测试让我做。单纯的我当然以为她发给我的是编程题。讲道理我也没见过哪个不是技术性问题的测试。但这次还真就被我撞上了。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一部分类似智商问卷。我中学的时候测出来的智商是143，就算我熬夜这么多年我想我的智商也不会掉到100去。事实也正是如此，不管是计算题、瑞文图形题还是3D空间变换都没有难到我。但是我万万没想到接下来的题竟然是考验英语能力的题。这一部分总共有三种题，平均每道题有6秒的答题时间。总题量超过之前的数学问题和智商问题的总和：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种是字母排列问题。比如ABC和DEF是相似的排列，因为他们都有123的顺序。同理，ZYX和CBA也有着相同的321顺序。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二种是造词题。给出随机的至少10个英文字母A和目标长度L，要求从A中选取L个字母组成一个单词。比如，给出CENZOKX和长度4，我可以组成XEON这个单词。可以看出随着A和L的增长，这道题的难度乘指数级增长。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三种是乱序单词游戏(Scrabled Word Game)。给出随机的至少12个英文字母A，要求组成英文单词。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一种题并不困难，因为这其实不算英文题。但第二和第三种题对汉语母语的人太不友好了。因为汉字环境中成长的大脑根本无法形成还原乱序单词的功能。这是因为中文是世界上唯一存活的语素文字，而世界上大部分的人使用的都是表音文字。我可以还原一个乱序的句子或是成语，但我做不到拼凑乱序单词。就像你给我十几个笔画，我需要很长的时间才能凑出一个文字一样。也许对于拉丁语系的人来说这是个很容易的题，对于汉语背景的人，在6秒钟内做出来真的是太难了。难到我甚至怀疑这是不是专门用来筛选华侨的问卷。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后来我去看了他们公司的领英，又查了查他们的员工。这是个不到60人的小公司，查起来非常容易。结果是除了一个只会说英语的华裔外，这个公司的确没有任何一个汉语姓的员工。唉，我想如果他们要筛选中国人的话这应该是最不显眼的方法了。表面上它的确是在考验你的英语能力，但背后却考验你的生长环境，偏偏你还不能说他们这是故意的，实在是用心良苦啊。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事情的后续是，因为有很多公司使用这个人力资源软件，我在这个平台上投递的简历统统没有任何回复。而我在其他平台投递的简历至少有1/5~1/8的几率被邀请面试。这也许是一个概率问题，但真的没法让我不多想。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更让我苦恼的是，这次经历让我有种智商被怀疑的挫败感。的确，这不是一个理性的想法，毕竟第一部分的智商问卷我不可能错到哪里去。这种智商题除了手滑选错答案外很难出现出现蒙对或是粗心答错之类的失误。但它毕竟跟第二部分的英文题在同一张试卷上。虽然我对第二部分有诸多不满，但如果两份问卷是分开作答，分开给结果的，那我根本不会在乎我在英语题上的折戟。可恰恰因为两份卷子是并在一起的，且事后我只收到一份HR方面不作任何解释的拒信，这就让我怀疑是不是我第一部分也出了什么差错——明明不可能有什么差错才对的。唉，实在是，没话说，不知道该怎么说才好了。